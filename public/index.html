<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Girvan–Newman: Original vs After One Step</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      margin: 0;
      padding: 0;
      background: #0b0f17;
      color: #e6e6e6;
    }

    header {
      padding: 16px 24px;
      border-bottom: 1px solid #1f2937;
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .pill {
      background: #111827;
      border: 1px solid #374151;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: #a7b0c0;
    }

    main {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0;
      height: calc(100vh - 64px);
    }

    .panel {
      position: relative;
      border-right: 1px solid #1f2937;
    }

    .panel:last-child {
      border-right: none;
    }

    .panel h2 {
      position: absolute;
      top: 12px;
      left: 12px;
      margin: 0;
      font-size: 14px;
      font-weight: 600;
      color: #a7b0c0;
      background: #0b0f17de;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #1f2937;
    }

    svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .legend {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: #0b0f17de;
      border: 1px solid #1f2937;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      color: #cfd7e3;
    }

    .legend .item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }

    .legend .swatch {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      display: inline-block;
    }

    .footnote {
      position: absolute;
      bottom: 12px;
      right: 12px;
      font-size: 12px;
      color: #8ea0b8;
      background: #0b0f17de;
      border: 1px solid #1f2937;
      padding: 6px 10px;
      border-radius: 8px;
    }

    .badge {
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid #374151;
      background: #111827;
      color: #a7b0c0;
      font-size: 11px;
    }

    .link-removed {
      stroke-dasharray: 4 2;
    }
  </style>
</head>

<body>
  <header>
    <div class="pill">Big Data · Girvan–Newman (one step)</div>
    <div class="pill">Edge Betweenness</div>
    <div class="pill">Node.js + Express + D3 v7</div>
  </header>
  <main>
    <div class="panel" id="left">
      <h2>Original graph</h2><svg id="svg-left"></svg>
      <div class="footnote">Edge width ∝ betweenness</div>
    </div>
    <div class="panel" id="right">
      <h2>After removing highest-betweenness edge</h2><svg id="svg-right"></svg>
      <div class="legend" id="legend"></div>
    </div>
  </main>

  <!-- D3 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    async function main() {
      const res = await fetch('/api/graphs');
      const data = await res.json();
      drawOriginal(data.original);
      drawAfter(data.after, data.original);
    }

    function drawOriginal(g) {
      const svg = d3.select('#svg-left');
      const width = svg.node().clientWidth;
      const height = svg.node().clientHeight;

      const gMain = svg.append('g')
        .attr('transform', `translate(${width / 2},${height / 2})`);
      const bet = g.betweenness || {};
      const maxBet = d3.max(Object.values(bet)) || 1;
      const strokeScale = d3.scaleLinear().domain([0, maxBet]).range([0.5, 5]);

      const simulation = d3.forceSimulation(g.nodes)
        .force('link', d3.forceLink(g.links).id(d => d.id).distance(60).strength(0.1))
        .force('charge', d3.forceManyBody().strength(-120))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collide', d3.forceCollide(18));

      const link = svg.append('g')
        .attr('stroke', '#718096')
        .attr('stroke-opacity', 0.8)
        .selectAll('line')
        .data(g.links)
        .join('line')
        .attr('stroke-width', d => {
          const key = edgeKey(d.source, d.target);
          return strokeScale(bet[key] || 0.1);
        })
        .attr('class', d => edgeKey(d.source, d.target) === g.removedEdge ? 'link-removed' : null)
        .attr('stroke', d => edgeKey(d.source, d.target) === g.removedEdge ? '#ef4444' : '#718096');

      const node = svg.append('g')
        .selectAll('circle')
        .data(g.nodes)
        .join('circle')
        .attr('r', 7)
        .attr('fill', '#93c5fd')
        .attr('stroke', '#1e293b')
        .attr('stroke-width', 1.2)
        .call(drag(simulation));

      const label = svg.append('g')
        .selectAll('text')
        .data(g.nodes)
        .join('text')
        .text(d => d.label)
        .attr('font-size', 11)
        .attr('fill', '#93c5fd')
        .attr('stroke', '#0b0f17')
        .attr('stroke-width', 3)
        .attr('paint-order', 'stroke');

      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
        node
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);
        label
          .attr('x', d => d.x + 9)
          .attr('y', d => d.y + 4);
      });
    }

    function drawAfter(gAfter, gOriginal) {
      const svg = d3.select('#svg-right');
      const width = svg.node().clientWidth;
      const height = svg.node().clientHeight;

      // Color by community id
      const communities = Array.from(new Set(gAfter.nodes.map(n => n.community)));
      const color = d3.scaleOrdinal(d3.schemeTableau10).domain(communities);

      const simulation = d3.forceSimulation(gAfter.nodes)
        .force('link', d3.forceLink(gAfter.links).id(d => d.id).distance(60).strength(0.1))
        .force('charge', d3.forceManyBody().strength(-120))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collide', d3.forceCollide(18));

      const link = svg.append('g')
        .attr('stroke', '#718096')
        .attr('stroke-opacity', 0.7)
        .selectAll('line')
        .data(gAfter.links)
        .join('line')
        .attr('stroke-width', 1.5);

      const node = svg.append('g')
        .selectAll('circle')
        .data(gAfter.nodes)
        .join('circle')
        .attr('r', 7)
        .attr('fill', d => d.community != null ? color(d.community) : '#93c5fd')
        .attr('stroke', '#1e293b')
        .attr('stroke-width', 1.2)
        .call(drag(simulation));

      const label = svg.append('g')
        .selectAll('text')
        .data(gAfter.nodes)
        .join('text')
        .text(d => d.label)
        .attr('font-size', 11)
        .attr('fill', '#93c5fd')
        .attr('stroke', '#0b0f17')
        .attr('stroke-width', 3)
        .attr('paint-order', 'stroke');

      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
        node
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);
        label
          .attr('x', d => d.x + 9)
          .attr('y', d => d.y + 4);
      });

      // Legend
      const legend = d3.select('#legend');
      legend.selectAll('div.item')
        .data(communities)
        .join('div')
        .attr('class', 'item')
        .html(c => `<span class="swatch" style="background:${color(c)}"></span> Community <span class="badge">#${c}</span>`);
    }

    function drag(simulation) {
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }
      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
      return d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended);
    }

    function edgeKey(a, b) {
      const u = (typeof a === 'object') ? a.id : a;
      const v = (typeof b === 'object') ? b.id : b;
      return (u < v) ? `${u}|${v}` : `${v}|${u}`;
    }

    main();
  </script>
</body>

</html>